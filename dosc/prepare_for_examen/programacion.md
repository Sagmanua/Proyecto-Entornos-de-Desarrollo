## planner.php
if (isset($_POST['save_menu'])) { // 1. Проверяем, была ли нажата кнопка "save_menu"
    $date = $_POST['planned_date']; // Получаем дату из формы
    $recipe_id = $_POST['id_recipe']; // Получаем ID рецепта
    $type = $_POST['meal_type']; // Получаем тип (завтрак/обед/ужин)
    
    // 2. Используем ПОДГОТОВЛЕННОЕ ВЫРАЖЕНИЕ (Prepared Statement) для безопасности
    $stmt = $conn->prepare("INSERT INTO menus (plannes_date, id_recipe, id_user, meal_type) VALUES (?, ?, ?, ?)");
    
    // 3. "Привязываем" переменные к знакам вопроса
    // "siis" означает типы данных: string (строка), integer (целое), integer, string
    $stmt->bind_param("siis", $date, $recipe_id, $user_id, $type);
    
    // 4. Выполняем команду записи в базу данных
    $stmt->execute();
    
    echo "<p class='success-msg'>Meal added to your plan!</p>"; // Сообщение об успехе
}



Al primero conecta a `head.php` que contiene la `conecion_bd.php` 
```
include "actions/head.php"; 
```



2. Безопасное выполнение ((Prepared Statement)


$stmt = $conn->prepare($sql);
$stmt->bind_param("i", $user_id); // "i" означает, что $user_id — это целое число (integer)
$stmt->execute();
$result = $stmt->get_result(); // Получаем результат запроса

## recipe_details.php
3. Важные функции безопасности и форматирования
В этой строке используются две очень полезные функции:

PHP

nl2br(htmlspecialchars($step['step_description']))
htmlspecialchars(): Безопасность. Она нейтрализует любые HTML-теги, которые могли случайно или намеренно попасть в описание (защита от XSS-атак).

nl2br(): Форматирование. Расшифровывается как Newline to BR. Она ищет в тексте обычные переносы строк (нажатия клавиши Enter) и заменяет их на HTML-тег <br>. Без этой функции весь текст описания шага слипся бы в одну длинную строку.

## logout.php

. session_start();
Прежде чем удалять сессию, PHP должен «вспомнить», какая именно сессия сейчас активна. Эта команда подключается к текущей сессии пользователя.

2. $_SESSION = array();
Эта строка очищает все данные внутри сессии. Если там хранились user_id, username или role, после этой команды массив становится абсолютно пустым.

3. Удаление Cookie сессии
Это самая технически сложная часть кода, и она очень важна для безопасности:

PHP

if (ini_get("session.use_cookies")) {
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000,
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"]


        тот код представляет собой универсальный механизм управления данными (CRUD) — он позволяет создавать, редактировать и удалять записи в базе данных. Такие скрипты часто используются в админ-панелях.

Однако, внимание: этот код содержит серьезные уязвимости в безопасности. Давайте разберем его логику и риски.
## crud.php
1. Логика подготовки данных
PHP

$table = $_REQUEST['table_name'] ?? 'USER';
$edit_id = $_GET['edit'] ?? null;
$row_to_edit = $edit_id ? $conn->query("SELECT * FROM $table WHERE id=$edit_id")->fetch_assoc() : null;
Динамическая таблица: Скрипт берет имя таблицы прямо из URL. Если в адресе написано ?table_name=recipes, он будет работать с рецептами.

Режим редактирования: Если в URL есть edit=5, скрипт ищет в базе строку с этим ID, чтобы предзаполнить форму для редактирования.

2. Сохранение (Insert или Update)
Скрипт проверяет, передано ли id через скрытое поле формы:

Update (Обновление): Если id есть, формируется строка SET колонка='значение' для каждого поля.

Insert (Вставка): Если id нет, создается новая запись. Используется array_keys, чтобы автоматически получить имена колонок из названий полей формы.

real_escape_string: Это базовая попытка очистить данные от кавычек, чтобы программа не сломалась при вводе текста типа L'Oreal.

3. Удаление (Delete) и целостность данных
PHP

$conn->query("DELETE FROM recipe_ingredient WHERE id_ingredient = $id"); // Удаление зависимостей
$conn->query("DELETE FROM ingredient WHERE id = $id"); // Удаление основного объекта
Здесь показан важный принцип связанных таблиц. Нельзя просто удалить ингредиент, если он используется в рецепте — это вызовет ошибку в базе (или оставит "мусор"). Поэтому сначала удаляются связи в таблице-посреднике (recipe_ingredient), а затем сам ингредиент.

1. Скрытые поля (Hidden inputs)
HTML

<input type="hidden" name="table_name" value="<?= $table ?>">
<?php if($edit_id): ?> <input type="hidden" name="id" value="<?= $edit_id ?>"> <?php endif; ?>
Эти данные не видны пользователю, но отправляются на сервер.

Они сообщают скрипту: "в какую таблицу сохранять" и "какую запись обновлять" (если мы в режиме редактирования).

2. Магия команды DESCRIBE
PHP

$res = $conn->query("DESCRIBE $table");
Это ключевой момент. Команда SQL DESCRIBE запрашивает у базы данных структуру таблицы (список всех колонок, их типы данных и свойства).

3. Генерация полей формы
Вместо того чтобы вручную прописывать <input> для каждого поля, цикл while делает это за вас:

Пропуск ID: if($col['Extra'] == 'auto_increment') continue; — форма не создает поле для первичного ключа (ID), так как база данных генерирует его сама.

Имена полей: $name = $col['Field']; — PHP берет название колонки из базы (например, title, price или description) и использует его для подписи (label) и имени инпута (name="f[...]").

Массив f[]: Обратите внимание на name="f[<?= $name ?>]". Все данные из формы придут в PHP в виде одного ассоциативного массива $_POST['f'], что позволяет легко обработать их циклом foreach.

4. Режим редактирования
PHP

value="<?= $row_to_edit[$name] ?? '' ?>"
Если мы редактируем существующую запись, в инпуты автоматически подставляются текущие значения из переменной $row_to_edit, которую мы получили ранее. Если это создание новой записи — поля остаются пустыми.